<!DOCTYPE html>
<html>
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Windows version 5.6.0">
  <title>MathJax Test Page</title>
  <!-- Copyright (c) 2009-2017 The MathJax Consortium -->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" href="bootstrap4/css/bootstrap.css">

<script type="text/x-mathjax-config">
  //MathJax.Ajax.timeout = 13*1000;   // timeout for loading of files (15 seconds)
  MathJax.Ajax.config.path.Contrib = "../../mathjax-third-party-extensions/legacy";

  MathJax.Hub.Config({
    //config: ["MMLorHTML.js"],
    extensions: [
      "tex2jax.js",
      "mml2jax.js",
      "asciimath2jax.js",
      //"CHTML-preview.js",
      //"fast-preview.js",
      "FontWarnings.js",
      "MatchWebFonts.js",
      "[Contrib]/longdiv/unpacked/longdiv.js",
      "[Contrib]/counters/counters.js",
    ],
    //jax: [ "input/TeX", "input/AsciiMath", "input/MathML", "output/HTML-CSS", "output/PreviewHTML", "output/SVG", "output/PlainSource" ],
    jax: [ "input/TeX", "input/AsciiMath", "input/MathML", "output/SVG" ],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true,
      processEnvironments: true,
    },
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "bbox.js",
        "begingroup.js",
        "cancel.js",
        "color.js",
        "enclose.js",
        "extpfeil.js",
        "mathchoice.js",
        "mediawiki-texvc.js",
        "newcommand.js",
        "noErrors.js",
        "noUndefined.js",
        "unicode.js",
        "verb.js",
      ],
      equationNumbers: {autoNumber: "AMS"},
    },
    showProcessingMessages: true,
    showMathMenu: true,
    menuSettings: {
      assistiveMML: false,    // do not produce any 'assistive' MathML-within-SPAN
      FastPreview: false,     // do not produce a preview SPAN
    },
    CommonHTML: {
      font: "Gyre-Pagella",
    },
    "HTML-CSS": {
      preferredFont: "Gyre-Pagella",
      linebreaks: {
        automatic: true,
        width: "container",
      },
      EqnChunkDelay: 1,
      noReflows: false,
    },
    SVG: {
      font: "Gyre-Pagella",
    },
    errorSettings: {
      // message: ["[Math Error]"],
    }
  });
</script>

<style>
body {
  max-width: 70em;
  margin: 0 auto;
}
h1 {
  text-align: center;
}
h2 {
  font-weight: bold;
  background-color: #DDDDDD;
  padding: .2em .5em;
  margin-top: 1.5em;
  border-top: 3px solid #666666;
  border-bottom: 2px solid #999999;
}
h3 {
  padding-top: 2em;
  padding-bottom: 1em;
}
blockquote {
  border: 1px solid #ccdee3;
  padding: .25em 1em;
  margin: 2em 5em;
  background-color: #e9f7fb;
}
blockquote blockquote {
  border: 1px solid #ccdee3;
  padding: .25em 1em;
  margin: 2em 1em 2em 1em;
  background-color: #f8fbfb;
}
def {
  font-weight: 500;
  font-style: italic;
}
article pre {
  white-space: pre-line;
}

/* prevent oversized output from producing horizontal scroll bar */
div.width-limited {
  max-width: 100%;
  overflow: auto;
  margin: 1em 0 1em 0;
  border: 1px dotted grey;
  background-color: #f7f7f7;
  padding: 0.2em 1em;
}

/* diagnostic style: */
.MathJax_SVG_Display,
.MathJax_SVG {
  border: 1px solid red           !important;
  background-color: #f7f7f7;
}

@media print {
  body {
    margin: 1in .7in 1in 1.4in;
    max-width: 100%;

    font-size: 85%;
  }
  blockquote {
    page-break-before: avoid;
    page-break-inside: auto;
    margin: 1em 1em;
  }
}
</style>

<script type="text/x-mathjax-config">
  MathJax.Hub.Register.StartupHook("TeX Jax Ready", function () {
    var TEX = MathJax.InputJax.TeX;
    var PREFILTER = TEX.prefilterMath;
    TEX.Augment({
      prefilterMath: function (math, displaymode, script) {
        console.log("TeX rendering Math:", {math, displaymode, script});
        //math = "\\displaystyle{" + math + "}";
        //math = "\\mathsf{" + math + "}";
        return PREFILTER.call(TEX, math, displaymode, script);
      }
    });

    var AM = MathJax.InputJax.AsciiMath;
    var AMPREFILTER = AM.prefilterMath;
    AM.Augment({
      prefilterMath: function (math, displaymode, script) {
        console.log("AsciiMath rendering Math:", {math, displaymode, script});
        return AMPREFILTER.call(AM, math, displaymode, script);
      }
    });
  });
</script>
<!--
  WARNING:

MathJax.js script must load AFTER ALL text/x-mathjax-config SCRIPTS have been defined
as those scripts won't otherwise be detected by MathJax (ConfigBlocks() internal call)
on startup as the init code is executed immeditately once the MathJax script has loaded!
-->

<script type="text/javascript" src="../MathJax.js"></script>
</head>
<body>
  <noscript>
  <div style="color:#CC0000; text-align:center">
    <b>Warning: <a href="http://www.mathjax.org/">MathJax</a> requires JavaScript to
    process the mathematics on this page.<br>
    If your browser supports JavaScript, be sure it is enabled.</b>
  </div>
  <hr>
  </noscript>

  <article>
    <h1>Sample MathJax Equations</h1>

<section>
  <h2>TeX sample files</h2>

<h3>
Triangle</h3>

<p>
Let the right triangle hypothenuse be aligned with the coordinate system *x-axis*.
The vector loop closure equation then reads

$$a{\bold e}_\alpha + b\tilde{\bold e}_\alpha + c{\bold e}_x = \bold 0$$ 

<p>
with

$${\bold e}_\alpha = \begin{pmatrix}\cos\alpha\\ \sin\alpha\end{pmatrix}    

\quad \text{and} \quad    

{\tilde{\bold e}}_\alpha = \begin{pmatrix}-\sin\alpha\\ \cos\alpha\end{pmatrix}$$

<p>
Resolving for the hypothenuse part $c{\bold e}_x$ in the loop closure equation 

$$-c{\bold e}_x = a{\bold e}_\alpha + b\tilde{\bold e}_\alpha$$

<p>
and squaring finally results in the Pythagorean theorem 

$$ c^2 = a^2 + b^2 $$ 




  <p>
 === FILE:  ./test/axiom_of_power_set.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}


  <p>
\[
{ \displaystyle
   \forall A \, \exists P \, \forall B \, [B \in P \iff \forall C \, (C \in B \Rightarrow C \in A)]
}
\]

  <hr>

  <p>
 === FILE:  ./test/binomial_coefficient.tex  === 

  <p>
\usepackage{amssymb,amsmath}
\begin{document}

  <p>
\[
{ \displaystyle
   \mathbf{C}(n,k) = \mathbf{C}_k^n = {}_n\mathbf{C}_k = \dbinom{n}{k} = \dfrac{n!}{k!\,(n -k)!}
}
\]

  <hr>

  <p>
 === array tests === 


<p>
\[
\begin{array}{*{3}{c@{\: +\: }}c@{\; =\; }c}
R_{1,1} \beta _{1} & R_{1,2} \beta _{2} & \cdots & R_{1,p} \beta _{p} & q_{1} \\
R_{2,1} \beta _{1} & R_{2,2} \beta _{2} & \cdots & R_{2,p} \beta _{p} & q_{2} \\
\multicolumn{5}{c}{\dotfill } \\
R_{r,1} \beta _{1} & R_{r,2} \beta _{2} & \cdots & R_{r,p} \beta _{p} & q_{r} \\
\end{array}
\]

<p>
Davide P. Cervone 

2/14/14

How about something like this:

<p>
  \begin{align}
  R_{1,1} \beta _{1} + R_{1,2} \beta _{2} + \cdots + R_{1,p} \beta _{p} &= q_{1} \\
  R_{2,1} \beta _{1} + R_{2,2} \beta _{2} + \cdots + R_{2,p} \beta _{p} &= q_{2} \\
  ..............................&.....\\
  R_{r,1} \beta _{1} + R_{r,2} \beta _{2} + \cdots + R_{r,p} \beta _{p} &= q_{r}
  \end{align}

<p>
This seems a bit more direct that the complicated align template, and since the terms are all the same size anyway, there is no need for that.

<p>
Davide

<p>
Beautiful solution Davide! I've noticed that making these 'wild' latex equations mathjax friendly generally makes the code and display cleaner.
Your align definitely is cleaner than the original array.

<p>How is this? 

<p>
\begin{eqnarray*} R_{1,1} \beta _{1} + R_{1,2} \beta _{2} + & \cdots & +\, R_{1,p} \beta _{p} = q_{1} \\ R_{2,1} \beta _{1} + R_{2,2} \beta _{2} + & \cdots & +\, R_{2,p} \beta _{p} = q_{2} \\ & \vdots & \\ R_{r,1} \beta _{1} + R_{r,2} \beta _{2} + & \cdots & +\, R_{r,p} \beta _{p} = q_{r} \end{eqnarray*}





  <hr><p>
 === FILE:  ./test/cichons_diagram.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}
\usepackage{multirow}

  <p>
\[
{ \displaystyle
\begin{array}{ccccccccccc}
                        &                 & {\rm cov}({\mathcal L}) & \longrightarrow & {\rm non}({\mathcal K}) & \longrightarrow & {\rm cof}({\mathcal K}) & \longrightarrow & {\rm cof}({\mathcal L}) & \longrightarrow & 2^{\aleph_0} \\

                        &                 & \multirow{3}{*}{\Bigg\uparrow} &          & \uparrow                &                 & \uparrow                &                 & \multirow{3}{*}{\Bigg\uparrow} &          & \\

                        &                 &                         &                 & {\mathfrak b}           & \longrightarrow & {\mathfrak d}           &                 &                         &                 & \\

                        &                 &                         &                 & \uparrow                &                 & \uparrow                &                 &                         &                 & \\

\aleph_1                & \longrightarrow & {\rm add}({\mathcal L}) & \longrightarrow & {\rm add}({\mathcal K}) & \longrightarrow & {\rm cov}({\mathcal K}) & \longrightarrow & {\rm non}({\mathcal L}) &                 &
\end{array}
}
\]


  <p>
Redone using the array-in-array solution suggestions from StackOverflow:

\[
\displaystyle
\begin{array}{ccccccccccc}
                        &                 & {\rm cov}({\mathcal L}) & \longrightarrow & {\rm non}({\mathcal K}) &
                          \longrightarrow & {\rm cof}({\mathcal K}) & \longrightarrow & {\rm cof}({\mathcal L}) &
                          \longrightarrow & 2^{\aleph_0} \\

                        &                 & \Bigg\uparrow &          & 
\begin{array}{c}
                        \uparrow \\
                        {\mathfrak b} \\
                        \uparrow 
\end{array}       &
\begin{array}{c}
                        \, \\
                        \longrightarrow \\
                        \, 
\end{array}       &
\begin{array}{c}
                        \uparrow \\
                        {\mathfrak d} \\
                        \uparrow 
\end{array}       &

                                          & {\Bigg\uparrow} &          & \\


\aleph_1                & \longrightarrow & {\rm add}({\mathcal L}) & \longrightarrow & {\rm add}({\mathcal K}) &
                          \longrightarrow & {\rm cov}({\mathcal K}) & \longrightarrow & {\rm non}({\mathcal L}) &
                                          &
\end{array}
\]



<h4>
Spacing in Math Mode</h4>

<p>
In a math environment, LaTeX ignores the spaces you type and puts in the spacing that it thinks is best. LaTeX formats mathematics the way it's done in mathematics texts. If you want different spacing, LaTeX provides the following four commands for use in math mode:

<ul>
  <li>
\; - a thick space
  <li>
\: - a medium space
  <li>
\, - a thin space
  <li>
\! - a negative thin space
</li></ul>


<h4>Multicol and multirow in MathJax</h4>

<p>
Too few reputation points to edit someone else's post, so I post a follow-up to Américo Tavares answer as my own answer — here's a cell split into rows

$$
\begin{array}{c|c}
 a^2-b^2 & 
 \begin{array}{ccc} 1+i & 1-i & \frac{1}{\sqrt{2}}
 \end{array} \\\hline  
 \color{green}{
 \begin{array}{c}a-b \\  a+b \end{array}
 } & \sqrt {2}
\end{array}
$$

<p>
The real problem is cross-row or cross-column alignment:

$$
\begin{array}{c|c}
 a^2-b^2 & 
 \begin{array}{ccc} 1+i & 1-i & \frac{1}{\sqrt{2}}
 \end{array} \\\hline  
 \begin{array}{c}
\color{green}{1+\cfrac 1 {1+\cfrac 1 {1+\cfrac 1\dots}} } \\ \color{blue}{aaaaaaa}
 \end{array} & 
 \begin{array}{c}
\color{green}{bbbbbbb} \\ \color{blue}{2+\cfrac 2 {2+\cfrac 2 {2+\cfrac 2\dots}} }
 \end{array}
\end{array}
$$

<hr>
<p>
  You might split cells instead by using nested arrays, as in the following example

<p>
It is generated by

$$
\begin{array}{c|c}
a^2-b^2 & 
 \begin{array}{ccc} 1+i & 1-i & \frac{1}{\sqrt{2}}
 \end{array} \\\hline  
 \begin{array}{cc}a-b &  a+b
 \end{array} & \sqrt {2}
\end{array}
$$

<p>
Américo Tavares

<hr>

  <p>
 === FILE:  ./test/complex_number.tex  === 

  <p>
<strong>Note the definition of <dfn>\thickspace</dfn> et al, as those do NOT come standard with MathJax:</strong>

  <p>
\[
\newcommand\thickspace{
    \;
}
\newcommand\thinspace{
    \,
}
\newcommand\mspace{
    \:
}

{ \displaystyle
 c = \overbrace
     { \underbrace{\thickspace\thickspace\thickspace\thickspace\thickspace a \thickspace\thickspace\thickspace\thickspace}_\text{real}
       +
       \underbrace{\thickspace\thickspace\thickspace\thickspace\thickspace b\mathrm{i} \thickspace\thickspace\thickspace\thickspace}_\text{imaginary}
     }^\text{complex number}
}
\]

  <hr>

  <p>
 === FILE:  ./test/deMorgans_law.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}
\setlength\parskip{-0.15in}

  <p>
Logic:

  <p>
\[
{ \displaystyle
  \neg(p\wedge q)\iff(\neg p)\vee(\neg q)
}
\]

  <p>
Boolean algebra:

  <p>
\[
{ \displaystyle
  \overline{\bigcup_{i=1}^{n} A_{i}}=\bigcap_{i=1}^{n} \overline{A_{i}}
}
\]

  <hr>
  <p>

 === FILE:  ./test/differentiable_manifold.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}

  <p>
\[
{ \displaystyle
   \gamma_1\equiv \gamma_2 \iff \left\{ \begin{array}{l} \gamma_1(0)=\gamma_2(0)=p, \text{ and }\\ [1.0ex]
   \left.\frac{\mathrm{d}}{\mathrm{d}t}\phi\circ\gamma_1(t)\right|_{t=0} = \left.\frac{\mathrm{d}}{\mathrm{d}t}\phi\circ\gamma_2(t)\right|_{t=0}
   \end{array} \right.
}
\]

  <hr>
  <p>

 === FILE:  ./test/divergence.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}

  <p>
\[
{ \displaystyle
   \nabla \cdot \vec v =
   {\partial v_x \over \partial x} +
   {\partial v_y \over \partial y} +
   {\partial v_z \over \partial z}
}
\]


  <hr>
  <p>

 === FILE:  ./test/font_sizes.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}
\usepackage{multirow}

  <p>
    \[
  \Huge{Huge}, \Large{Large}, \normalsize{normalsize}, \small{small}
  \]

  <hr>
  <p>

 === FILE:  ./test/moore_determinant.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}

  <p>
\[
{ \displaystyle
   M =
   \begin{bmatrix}
     \alpha_1 & \alpha_1^q & \cdots & \alpha_1^{q^{n - 1}} \\
     \alpha_2 & \alpha_2^q & \cdots & \alpha_2^{q^{n - 1}} \\
     \vdots   & \vdots     & \ddots & \vdots             \\
     \alpha_m & \alpha_m^q & \cdots & \alpha_m^{q^{n - 1}}
   \end{bmatrix}
}
\]

  <hr>
  <p>

 === FILE:  ./test/multiscripts_and_greek_alphabet.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}

  <p>
\[
{ \displaystyle
   \sideset{_{{}_\alpha^\beta\mathfrak{A}_\delta^\gamma}^{{}_\epsilon^\zeta\mathfrak{B}_\theta^\eta}}{_{{}_\rho^\sigma\mathfrak{E}_\upsilon^\tau}^{{}_\nu^\xi\mathfrak{D}_\pi^o}}\prod_{{}_\phi^\chi\mathfrak{F}_\omega^\psi}^{{}_\iota^\kappa\mathfrak{C}_\mu^\lambda}
}
\]

  <hr>
  <p>
 === FILE:  ./test/nested_matrices.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}
\usepackage{multirow}

  <p>
\[
{ \displaystyle
   \left(
     \begin{array}{@{}r@{}l@{}}
       \left(
         \begin{array}{llrr}
           a_1 & a_2 \thickspace & a_3 & a_4 \\
           a_5 & a_6 \thickspace & a_7 & a_8 \\
         \end{array}
       \right)
     &
       \multirow{2}{*}[1.4ex]
       {$
         \left(
           \begin{array}{c}
             b_1 \\
             b_2 \\ [0.3ex]
             b_3 \\
             b_4 \\
           \end{array}
         \right)
       $}
     \\ [1.7ex]
       \begin{array}{lr@{}}
         $\raisebox{-0.5ex}{\Large 0}$\thinspace
         &
         \left(
           \begin{array}{rr}
             c_1 \thinspace & c_2 \\
             c_3 \thinspace & c_4 \\
           \end{array}
         \right)
       \end{array}
     &
     \end{array}
   \right)
}
\]


  <hr>
  <p>

 === FILE:  ./test/nested_roots.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}

  <p>
\[
{ \displaystyle
   \frac{\sqrt{1 + \sqrt[3]{2 + \sqrt[5]{3 + \sqrt[7]{4 + \sqrt[11]{5 + \sqrt[13]{6 + \sqrt[17]{7 + \sqrt[19]{A}}}}}}}}}{\mathrm{e}^\pi} = x^{'''}
}
\]

  <hr>
  <p>

 === FILE:  ./test/schwinger_dyson.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}

  <p>
\[
{ \displaystyle
   \left\langle\psi\left|\mathcal{T}\left\{\frac{\delta}{\delta\phi}F[\phi]\right\}\right|\psi\right\rangle = -\mathrm{i}\left\langle\psi\left|\mathcal{T}\left\{F[\phi]\frac{\delta}{\delta\phi}S[\phi]\right\}\right|\psi\right\rangle
}
\]

  <hr>
  <p>
 === FILE:  ./test/sophomores_dream.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}

  <p>
\[
{ \displaystyle
   \int_0^1 x^x\,\mathrm{d}x = \sum_{n = 1}^\infty{(-1)^{n + 1}\,n^{-n}}
}
\]
  <hr>
  <p>
 === FILE:  ./test/sphere_volume.tex  === 

  <p>
\documentclass[12pt]{article}
\usepackage{amssymb,amsmath}
\usepackage{multirow}

  <p>
Spherical coordinates derivation of the volume of a sphere $ \left(\tfrac43 \pi R^3 \right) $.
<p>
The formula $S$ for a sphere of radius $R$ in spherical coordinates is: 
<p>
$ S = \{0 \leq \phi \leq 2\pi, \ 0 \leq \theta \leq \pi, \ 0 \leq \rho \leq R\} $

  <p>
\begin{align*}
\mathrm{Volume} &=\iiint\limits_S\! \rho^2 \sin\theta \,\mathrm{d}\rho \,\mathrm{d}\theta \,\mathrm{d}\phi \\
&=\int_0^{2 \pi }\! \mathrm{d}\phi \,\int_0^{ \pi }\! \sin\theta \,\mathrm{d}\theta \,\int_0^R\! \rho^2 \mathrm{d}\rho \\
&=\phi \Bigr|_0^{2\pi}\ (-\cos\theta) \Bigr|_0^{ \pi }\ \tfrac13 \rho^3 \Bigr|_0^R \\
&=2\pi \times 2 \times \tfrac13 R^3 \\
&=\tfrac43 \pi R^3
\end{align*}

  <hr>

  <p>
\[
  \mathrm{kgv}(15,27) = \frac{|15\times 27|}{\mathrm{ggd}(15,27)} = \frac{405}{3} = 135
\]

<hr>

<p>
  {{Wiskunde}}

<p>
== Inleiding ==

<p>
Welke van de volgende rekensommen zijn juist?

<p>
  \[
 1 + 1 = 10      \\
 1 + 7 = 10      \\
 1 + 9 = 10      \\
 1 + \text{F} = 10      \\
 10 + 3 = 1      \\
 \text{I} + \text{IV} = \text{V}      \\
 10 + 350 = 0    
\]

<p>
Mocht je dit voorleggen aan een willekeurig persoon, dan bestaat de kans dat hij of zij zal aangeven dat enkel de derde juist is. Nochtans kunnen ze allemaal juist zijn, mits voldoende uitleg gegeven wordt over het soort talstelsel dat gebruikt wordt. In onze (westerse) wereld werken wij echter graag met machten van tien, in ons decimaal talstelsel. Het is ook logisch, want we hebben tien vingers.

<p>
 1 + 1 = 10, is juist in het binair talstelsel. Decimaal gezien staat er nl. 1 + 1 = 2.
<p>
 1 + 7 = 10, is juist in het octaal talstelsel. Decimaal gezien staat er nl. 1 + 7 = 8.
<p>
 1 + 9 = 10, is juist in het decimaal talstelsel.
<p>
 1 + F = 10, is juist in het hexadecimaal talstelsel. Decimaal gezien staat er nl. 1 + 15 = 16.
<p>
 10 + 3 = 1, is juist bij uren. Als het nu 10 uur is en je telt er 3 uur bij, is het inderdaad 1 uur.
<p>
 I + IV = V, is juist bij Romeinse cijfers. Decimaal gezien staat er nl. 1 + 4 = 5.
<p>
 10 + 350 = 0, is juist bij hoeken in graden: 10 + 350 = 360°. Dan ben je terug bij het begin, dus 0°. 

<p>
Zonder het te weten, gebruik je standaard al een '''talstelsel''' bij het rekenen: het ''decimale'' talstelsel. Maar hoe zit het dan met de andere talstelsels? Dit stuk gaat over het gebruik van verschillende [[w:Positiestelsel|positiestelsels]] en hoe je kunt omrekenen van het ene naar het andere. Het gaat dus niet over Romeinse cijfers, uren of hoeken. Uren en hoeken gaan zelfs niet zozeer over talstelsels, maar over [[Rekenen/Modulair rekenen|modulair rekenen]] (noodzakelijk bij bv. [[w:RSA (Cryptografie)|RSA]] en [[w:Cryptografie|cryptografie]]). Voor de [[Basiskennis informatica/Talstelsels|toepassingen van talstelsels in de informatica]] is een apart Wikibook voorzien.

<p>
== Leesbaarheidsregels ==
<p>
Om in dit hoofdstuk geen verwarring te krijgen tussen de verschillende talstelsels, worden alle getallen op de plek waar het niet uit de context opgemaakt kan worden, gevolgd door het grondtal van hun talstelsel tussen (). Zo staat 10<sub>(10)</sub> voor het getal 10 in het decimale stelsel en  10<sub>(2)</sub> voor het getal 2 (eigenlijk: 2<sub>(10)</sub>), weergegeven in het binaire stelsel. In het hexadecimale stelsel is het getal 10 (10<sub>(16)</sub>) het getal 16 in het decimale stelsel (16<sub>(10)</sub>).

<p>
Verder is het gebruikelijk om, wanneer je een getal binair opschrijft, de cijfers te groeperen per 4 of per 8, om de leesbaarheid te bevorderen. In dit hoofdstuk worden ze gegroepeerd per 4.

<p>
== Voorbeelden ==
<p>
Hoe "werkt" zo'n positiestelsel precies? Hoeveel kruisjes staan hier: XXXX? Dat zijn er vier. Normaal zal men dit aantal noteren als 4. Ook een IT'er die het hexadecimale stelsel gebruikt, schrijft voor dit aantal 4. Een computer daarentegen noteert in het binaire stelsel het aantal vier als 100? Het volgende aantal kruisjes, XXXXXXXXXXXXXXXX, is zestien. Dit aantal schrijft men gewoonlijk als 16, een IT'er in het hexadecimale stelsel echter als 10 en een computer schrijft 10000 in het binaire stelsel. Laten we dit eens bekijken aan de hand van enkele voorbeelden, om dan de algemene regels te presenteren.<ref>James May gebruikt hetzelfde idee in zijn filmpje ''[https://www.youtube.com/watch?v=kcTwu6TFZ08 What are binary numbers?]''</ref>

<p>
=== Het decimale talstelsel ===
<p>
Het decimale talstelsel is het meest gebruikte talstelsel. Dit talstelsel gebruikt tien (deca = tien) cijfers. Deze zijn:

<p>
:0 1 2 3 4 5 6 7 8 9

<p>
Iedereen zal hieronder drieëntwintig kruisjes zien staan, genoteerd als 23. Een computer schrijft in het binaire stelsel hiervoor 10111.

<p>
 XXXXXXXXXXXXXXXXXXXXXXX

<p>
Dat er 23 kruisjes staan, is gewoon een kwestie van tellen. Maar waarom schrijft men hiervoor in het decimale stelsel 23? Tijd dus voor een uitgebreide uitleg. Het tellen gebeurt zoals in een "ouderwetse" kilometerteller in de wagen of met een ouderwets kliksysteem zoals voor het tellen van bv. het aantal personen die ergens passeren:

<p>
<gallery>
Afbeelding:Odometer10.svg|Een decimale teller, waar je de volgende en de vorige cijfers ziet.
Afbeelding:Click1.jpg|Een decimale handteller
Afbeelding:Telraam 01.jpg|Een telraam met het getal 1981. 
</gallery>

<p>
Het telraam telt maar 100 kralen, maar toch kan men veel grotere getallen voorstellen. Dan wordt de eerste rij gebruikt voor het tellen van eenheden, de tweede rij voor tientallen, de derde rij voor honderdtallen,... Het getal op het telraam is dan niet 19, maar 1981.

<p>
Laten we de eerste negen kruisjes tellen.

<p>
Telvoorbeeld:
<p>
 dec kruisjes
   0 
   1 X
   2 XX
   3 XXX
   4 XXXX
   5 XXXXX
   6 XXXXXX
   7 XXXXXXX
   8 XXXXXXXX
   9 XXXXXXXXX

<p>
Tot nu toe kunnen we de aantallen kruisjes met  één symbool (cijfer) aangeven. Maar bij de volgende zitten we met een probleem: in het decimale talstelsel hebben we namelijk niet één symbool om het volgende kruisje voor te stellen. We weten echter dat we verder kunnen tellen met:

<p>
 dec kruisjes
  10 XXXXXXXXXX
  11 XXXXXXXXXX X
  12 XXXXXXXXXX XX
  ...
  19 XXXXXXXXXX XXXXXXXXX

<p>
De reden dat dit "werkt" is omdat het decimaal talstelsel een [[w:Positiestelsel|positiestelsel]] is. Zo zijn 12 en 21 opgebouwd uit dezelfde cijfers - nl. '1' en '2' - maar zijn 12 en 21 toch niet dezelfde getallen. De '1' bij 12 is een tiental, wat betekent dat we al één groep van 10 kruisjes hebben. Bij '21' is het tiental een '2', wat betekent dat we al twee groepen van 10 kruisjes hebben.

<p>
Als we bij ons voorbeeld 19 één kruisje erbij plaatsen, hebben we een extra groep van tien kruisjes, bij de groep die we al hadden. We hebben dus twee groepen van tien kruisjes, wat we aangeven met 20. Zo kunnen we terug verder tellen:

<p>
 dec kruisjes
  20 XXXXXXXXXX XXXXXXXXXX
  21 XXXXXXXXXX XXXXXXXXXX X
  22 XXXXXXXXXX XXXXXXXXXX XX
  23 XXXXXXXXXX XXXXXXXXXX XXX

<p>
Dit tellen kunnen we verder doen tot bv. 99, wat betekent dat we 9 groepen van 10 kruisjes en een restgroepje van 9 kruisjes hebben. Als we er nu één kruisje bijplaatsen, hebben we 10 groepen van elk 10 kruisjes. Dit stellen we dan voor door het getal 100.

<p>
Het getal 162 betekent dan 1 groep van 10 keer 10 "kruisjes" (dus 10²) , 6 groepen van 10 "kruisjes" en 1 restgroep van 2 kruisjes. Of in formulevorm:

<p>
\[
1 \cdot 10^2 + 6 \cdot 10^1 + 2 \cdot 10^0 = 100 + 60 + 2 = 162
\]

<p>
=== Het binaire talstelsel ===
<p>
Het binaire talstelsel wordt bijna niet gebruikt door de mens. De hedendaagse computers werken bijna allemaal met binaire getallen: elektriciteit of geen elektriciteit, licht of geen licht,... Dit talstelsel gebruikt slechts twee (bi = twee) cijfers:

<p>
 0 1

<p>
We kunnen dezelfde methode gebruiken zoals bij het decimale talstelsel, namelijk door het tellen van kruisjes:

<p>
[[Afbeelding:Odometer2.svg|thumb|400px|Dit is een binair telwerk. Elk wieltje - voor zover men nog van wieltjes kan spreken - heeft slechts twee posities. Er zijn dan ook geen cijfers boven en onder het afleesvenster te zien.]]

<p>
 dec  bin  kruisjes
   0    0 
   1    1  X

<p>
Je zou geneigd zijn om '2' te noteren bij XX, maar het cijfer '2' is geen geldig cijfer in het binaire talstelsel. We merken echter op dat we één groep van twee X-en hebben. Bij het tellen van XX schrijven we binair dan ook 10. Vandaar ook de uitdrukking ''Er zijn 10 soorten mensen: diegene die binair begrijpen en diegene die dat niet kunnen''. Zo kunnen we verdertellen:

<p>
 dec  bin  kruisjes
   2   10  XX
   3   11  XX X

<p>
Als we nu een kruisje toevoegen t.e.m. XXXX, dan merken we dat we één groep van twee keer twee kruisjes hebben. Dit klinkt in woorden nogal ingewikkeld, maar als getal is dit het binaire getal 100:

<p>
 dec  bin  kruisjes
   4  100  XX XX
   5  101  XX XX X
   6  110  XX XX XX
   7  111  XX XX XX X
   8 1000  XX XX XX XX
   9 1001  XX XX XX XX X
  10 1010  XX XX XX XX XX
  11 1011  XX XX XX XX XX X
 ...

<p>
Het binaire getal 101 betekent dan 1 groep van 2 keer 2 "kruisjes" (dus 2<sup>2</sup>), 0 groepen van 2 "kruisjes" en 1 restgroep van 1 kruisje. Of in formulevorm:
$$ 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 4 + 0 + 1 = 5 $$. Dus 101<sub>(2)</sub> = 5<sub>(10)</sub>.

<p>
=== Het octale talstelsel ===
<p>
Het octale talstelsel wordt bijna niet meer gebruikt. Dit talstelsel gebruikt acht (octo = acht) cijfers:

<p>
 0 1 2 3 4 5 6 7

<p>
Telvoorbeeld:
<p>
 dec   bin   oct kruisjes
   0 000 000  0 
   1 000 001  1 X
   2 000 010  2 XX
   3 000 011  3 XXX
   4 000 100  4 XXXX
   5 000 101  5 XXXXX
   6 000 110  6 XXXXXX
   7 000 111  7 XXXXXXX
   8 001 000 10 XXXXXXXX
   9 001 001 11 XXXXXXXX X
  10 001 010 12 XXXXXXXX XX
  11 001 011 13 XXXXXXXX XXX
  12 001 100 14 XXXXXXXX XXXX
  ...
  15 001 111 17 XXXXXXXX XXXXXXX
  16 010 000 20 XXXXXXXX XXXXXXXX
  17 010 001 21 XXXXXXXX XXXXXXXX X
  18 010 010 22 XXXXXXXX XXXXXXXX XX

<p>
=== Het hexadecimale talstelsel ===
<p>
Men zocht naar een manier om met één symbool verder te kunnen tellen dan 9. Zo besloot men voor het hexadecimale talstelsel om verder te tellen met de letters A, B, C, D, E en F. Binnen het hexadecimale talstelsel zijn de letters A t/m F dus cijfers. De volledige lijst van de 16 (hexadeca = 16) cijfers is dus (van klein naar groot):

<p>
 0 1 2 3 4 5 6 7 8 9 A B C D E F

<p>
Opnieuw kunnen we het tellen als basis gebruiken:

<p>
[[Afbeelding:Odometer16.svg|thumb|150px|Een hexadecimale teller, waar je de volgende en de vorige cijfers ziet.]]

<p>
 dec hex kruisjes
   0   0 
   1   1 X
   2   2 XX
   ...
   9   9 XXXXXXXXX

<p>
Nu zijn we geneigd om 10 te plaatsen bij XXXXXXXXX, maar als we hetzelfde principe gebruiken zoals bij de andere talstelsels, dan betekent de '1' van '10' dat we al één groep van 16 kruisjes hebben. De decimale 10 kunnen we hier dus niet gebruiken. Als we kijken bij de gebruikte "cijfers" van het hexadecimale talstelsel, dan merken we dat na de '9' een 'A' komt. We kunnen dus verder tellen met:

<p>
 dec hex kruisjes
  10   A XXXXXXXXXX
  11   B XXXXXXXXXXX
  12   C XXXXXXXXXXXX
  13   D XXXXXXXXXXXXX
  14   E XXXXXXXXXXXXXX
  15   F XXXXXXXXXXXXXXX

<p>
Pas nu zijn we op het moment gekomen dat we een groep van 16 kruisjes zullen kunnen maken:

<p>
 dec hex kruisjes
  16  10 XXXXXXXXXXXXXXXX
  17  11 XXXXXXXXXXXXXXXX X
  18  12 XXXXXXXXXXXXXXXX XX
  ...
  26  1A XXXXXXXXXXXXXXXX XXXXXXXXXX
  27  1B XXXXXXXXXXXXXXXX XXXXXXXXXXX
  ...
  32  20 XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
  33  21 XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX X

<p>
Het hexadecimale getal 1A2 betekent dan 1 groep van 16 keer 16 "kruisjes" (dus 16<sup>2</sup>) , 10 (=A) groepen van 16 "kruisjes" en 1 restgroep van 2 kruisjes. Of in formulevorm: $$ 1 \cdot 16^2 + 10 \cdot 16^1 + 2 \cdot 16^0 = 256 + 160 + 2 = 418 $$. Dus 1A2<sub>(16)</sub> = 418<sub>(10)</sub>.

<p>
=== Overzicht ===
<p>
Een overzicht van de bekendste talstelsels:

<pre>
dec    bin oct hex kruisjes
  0      0   0   0 
  1      1   1   1 X
  2     10   2   2 XX
  3     11   3   3 XXX
  4    100   4   4 XXXX
  5    101   5   5 XXXXX
  6    110   6   6 XXXXXX
  7    111   7   7 XXXXXXX
  8   1000  10   8 XXXXXXXX
  9   1001  11   9 XXXXXXXXX
 10   1010  12   A XXXXXXXXXX
 11   1011  13   B XXXXXXXXXXX
 12   1100  14   C XXXXXXXXXXXX
 13   1101  15   D XXXXXXXXXXXXX
 14   1110  16   E XXXXXXXXXXXXXX
 15   1111  17   F XXXXXXXXXXXXXXX
 16  10000  20  10 XXXXXXXXXXXXXXXX
 17  10001  21  11 XXXXXXXXXXXXXXXXX
 18  10010  22  12 XXXXXXXXXXXXXXXXXX
 ...        
 30  11110  36  1E XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 31  11111  37  1F XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 32 100000  40  20 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 33 100001  41  21 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
</pre>

<p>
=== Wat zijn talstelsels? ===
<p>
Een talstelsel is een systeem om getallen weer te geven in de vorm van een rij cijfers. Bij de eerder besproken talstelsels bepaalt de plaats die een cijfer in de rij inneemt hoe we de bijdrage van dat cijfer aan het getal moeten interpreteren. We spreken dan ook over positiestelsels. Alhoewel de benaming 'decimaal talstelsel' gebruikelijk is, zou 'decimaal positiestelsel' duidelijker uitleggen dat we specifiek met een positiestelsel te maken hebben.

<p>
Merk op dat alle positiestelsels talstelsels zijn, maar niet alle talstelsels zijn positiestelsels. Zo is de waarde van I in het Romeinse getal IV '1', maar zo ook in het Romeinse getal VI. Dit is niet zo voor het decimale getal 21 versus 12: bij het tweede getal heeft '1' namelijk de waarde van '10'.

<p>
Merk op:
<p>
* Er kunnen nullen vóór het daadwerkelijke getal staan zonder de waarde ervan te beïnvloeden. Zo is 1 hetzelfde als 01 en 001. Bij het decimale talstelsel is het heel ongebruikelijk om voorloopnullen te laten staan, in de andere talstelsels wordt dit soms wel gedaan (bv. bij [[w:ASCII (tekenset)|ASCII]] of [[w:Wireshark|Wireshark]]).
<p>
* Alle talstelsels hebben een nul (0).
<p>
* Het grootste cijfer in een talstelsel is (grondtal - 1), omdat de nul ook meetelt als cijfer. Zo is het grootste cijfer in het decimale stelsel een 9 (decem = 10), in het octale stelsel een 7 (octo = 8) en in het binaire stelsel een 1 (bi = 2). De mogelijke cijfers komen dus altijd uit de reeks 0, 1,..., grondtal-1.

<p>
== Omrekenen ==
<p>
Om van het ene talstelsel om te rekenen naar het andere, zijn er een aantal methoden.

<p>
=== Van een ander stelsel naar het decimale stelsel ===
<p>
==== Algemeen ====
<p>
Een natuurlijk getal ''x'' laat zich in het decimale positiestelsel uitdrukken als een reeks van termen van machten van een ander natuurlijk getal, het grondtal, ''a'':

<p>
\[
\,x= \sum_{i=0}^{k} x_i a^i  
\]

of

\[
\,x = x_k a^k + ... + x_2 a^2 + x_1 a^1 + x_0 a^0 
\]

<p>
waarbij de coëfficiënten ''x''<sub>i</sub> natuurlijke getallen zijn kleiner dan het grondtal, of nul.

<p>
In het ''a''-tallige stelsel wordt ''x'' nu voorgesteld door de rij cijfers: 

<p>
\[
\,x_k...x_2x_1x_0
\]

<p>
De coëfficiënten x<sub>i</sub> vormen in volgorde de cijfers van het getal. Het meest linkse cijfer x<sub>k</sub> is de coëfficiënt van de hoogste macht van het grondtal, het meest rechtse x<sub>0</sub> de coëfficiënt van de eenheden (de 0-de macht van het grondtal). 

<p>
Bovenstaande formules zien er ingewikkeld uit, maar met een voorbeeld wordt alles duidelijker:
<p>
* Het decimale getal 1432 wordt met bovenstaande formule: $$ 1 \cdot 10^3 + 4 \cdot 10^2 + 3 \cdot 10^1 + 2 \cdot 10^0 = 1000 + 400 + 30 + 2 = 1432 $$
<p>
* In het octale stelsel, dus met grondtal 8, gebruikt men de cijfers 0, 1, ..., 7. Het getal 1432 in het octale stelsel betekent in het decimale stelsel: $$ 1 \cdot 8^3 + 4 \cdot 8^2 + 3 \cdot 8^1 + 2 \cdot 8^0 = 512 + 256 + 24 + 2 = 794 $$. Dus 1432<sub>(8)</sub>=794<sub>(10)</sub>.

<p>
==== 472<sub>(8)</sub> = ?<sub>(10)</sub> ====
<p>
Als voorbeeld hier het omrekenen van het octale getal 472<sub>(8)</sub> naar een decimaal getal.  We nemen de volgende stappen:
<p>
#Voor het bepalen van de positie tellen we vanaf 0 en niet vanaf 1.
<p>
#Bepaal voor elke positie het gewicht als het grondtal tot de macht de positie. Bij positie 2 is het gewicht dus 8<sup>2</sup>=64.
<p>
#Reken voor elk cijfer de bijdrage uit door het cijfer te vermenigvuldigen met het gewicht. Bij cijfer 4 is de bijdrage dus 4 * 64 = 256.
<p>
#Tel de bijdragen van de cijfers bij elkaar op.
<p>
De uitwerking is dus als volgt: het getal is 472<sub>(8)</sub>

<p>
\[
\begin{matrix}
\text{positie}&\text{gewicht}&\text{cijfer}&\text{bijdrage} \\
0 & \ 1 & 2 &\ \  2\\ 
1 & \ 8 & 7 &\  56\\ 
2 & 64 & 4 & 256\\ 
& \ & \text{totaal} & 314
\end{matrix}
\]

<p>
Het resultaat  is :

\[
\begin{matrix}
472_{(8)} & = & 4 * 8^2 + 7 * 8^1 + 2 * 8^0\\
 & = & 4 * 64 + 7 * 8 + 2 * 1\\
 & = & 256 + 56 + 2\\
 & = & 314
\end{matrix}
\]

<p>
Dus 472<sub>(8)</sub> = 314<sub>(10)</sub>. Merk op dat in bovenstaande uitwerking alles aan de rechterkant in het decimale talstelsel wordt uitgerekend.

<p>
==== 472<sub>(8)</sub> = ?<sub>(10)</sub>, met computeralgoritme ====
<p>
Bovenstaande methode wordt als mens vaak gebruikt, maar mocht je dit in een programma wensen te gieten, kan onderstaand recursief algoritme van pas komen:

<p>
# 'variabelen instellen
<p>
# in = inlezen getal
<p>
# grondtal = inlezen grondtal
<p>
# uit = meest linkse getal van in
<p>
# in = in, zonder meest linkse getal
<p>
# 
<p>
# 'lus
<p>
# uit = uit * grondtal
<p>
# getal = meest linkse getal van in
<p>
# uit = uit + getal
<p>
# in = in, zonder meest linkse getal. Als 'in' niet leeg, naar stap 8
<p>
# 
<p>
# 'antwoord
<p>
# output uit.

<p>
Voor het bovenstaande voorbeeld wordt dit:
<p>
# in = 472
<p>
# grondtal = 8
<p>
# uit = 4
<p>
# in = 72
<p>
# 
<p>
# uit = 4 * 8 = 32
<p>
# getal = 7
<p>
# uit = 32 + 7 = 39
<p>
# in = 2
<p>
# 
<p>
# uit = 39 * 8 = 312
<p>
# getal = 2
<p>
# uit = 312 + 2 = 314
<p>
# in = STOP
<p>
# 
<p>
# Het antwoord is 314

<p>
=== Van het decimale stelsel naar een ander stelsel ===
<p>
Het omrekenen van het decimale stelsel naar een ander stelsel is een stukje ingewikkelder. Het is met makkelijkst uit te leggen aan de hand van een voorbeeld.

<p>
==== 23<sub>(10)</sub> = ?<sub>(2)</sub> ====
<p>
Vanuit het tellen weten we al dat de basis van het binaire stelsel neerkomt op het maken van groepjes van twee. Dit kunnen we makkelijkst bepalen met de Euclidische deling.

<p>
  D / G =  Q R      Uitleg           Q                                 R
 --------------------------------------------------------------------------------------
 23 / 2 = 11 1  ^   23 = 11 * 2 + 1  XX XX XX XX XX XX XX XX XX XX XX  X
 11 / 2 =  5 1 /|\  11 =  5 * 2 + 1  XXXX XXXX XXXX XXXX XXXX          XX
  5 / 2 =  2 1  |    5 =  2 * 2 + 1  XXXXXXXX XXXXXXXX                 XXXX 
  2 / 2 =  1 0  |    2 =  1 * 2 + 0  XXXXXXXXXXXXXXXX
  1 / 2 =  0 1  |    1 =  0 * 2 + 1                                    XXXXXXXXXXXXXXXX

<p>
Uitleg:
<p>
# Blijkbaar kunnen we 11 groepen van 2 maken en hebben we 1 restgroep X.
<p>
# Bij de volgende stap proberen we te kijken hoeveel XX-groepjes we per twee kunnen samennemen. Blijkbaar kunnen we 10 XX-en samennemen tot 5 XXXX-en, waarbij er 1 restgroep XX is.
<p>
# Dit algoritme herhalen we: ditmaal kunnen we 4 XXXX-en samennemen tot 2 XXXXXXXX-en, met 1 restgroep XXXX.
<p>
# Bij de vierde stap kunnen we de XXXXXXXX en XXXXXXXX samennemen tot XXXXXXXXXXXXXXXX en hebben we geen restgroep.
<p>
# De vijfde stap wordt al eens over het hoofd gezien, maar we moeten blijven verderdelen tot het quotiënt 0 wordt. Daar we niets meer kunnen samennemen hebben we nu 1 restgroep XXXXXXXXXXXXXXXX.
<p>
# Voor het bepalen van het antwoord moeten we van beneden naar boven lezen en krijgen we: 23<sub>(10)</sub>=10111<sub>(2)</sub>

<p>
==== 1203<sub>(10)</sub> = ?<sub>(16)</sub> ====
<p>
Stel, we willen 1203<sub>(10)</sub> omzetten naar hexadecimaal. Hiervoor kunnen we hetzelfde algoritme gebruiken als het vorige voorbeeld. Het enige verschil is dat het grondtal (deler) ditmaal 16 is, maar ook hier blijven we delen tot we als quotiënt 0 uitkomen. De kruisjes worden deze keer achterwege gelaten, omdat er teveel zijn:

<pre>
   D /  G =  Q  R      Uitleg            
-------------------------------------------
1203 / 16 = 75  3  ^   1203 = 75 * 16 + 3  
  75 / 16 =  4 11 /|\    75 =  4 * 16 + 11 
   4 / 16 =  0  4  |      4 =  0 * 16 + 4  
</pre>

<p>
Merk op:
<p>
# Delen door 2 kunnen we gemakkelijk uit het hoofd, maar delen door 16 is moeilijker. Een klassiek rekentoestel kan een hulpmiddel zijn, maar rekent meestal niet Euclidisch. Toch kan je snel rekenen met: 1203 / 16 = 75,1875 ==> 75,1875 - 75 = 0,1875 ==> 0,1875 * 16 = 3.
<p>
# Opnieuw moet je van beneden naar boven aflezen, maar 4113 zou een fout antwoord zijn, want 4113<sub>(16)</sub> = 16659<sub>(10)</sub>. De '11' moeten we namelijk eerst omzetten naar een hexadecimaal "cijfer": 11<sub>(10)</sub> == B<sub>(16)</sub>.
<p>
# Het antwoord wordt dan: 1203<sub>(10)</sub> == 4B3<sub>(16)</sub>

<p>
=== Shortcuts ===
<p>
Om van het ene stelsel naar het andere om te rekenen, wordt vaak als tussenkomst het decimale stelsel gebruikt. Wil men van octaal naar hexadecimaal, dan is het vaak ''octaal -> decimaal -> hexadecimaal''. Dit vergroot de kans op rekenfouten aanzienlijk. Er zijn echter handigheidjes om van binair naar hexadecimaal om te rekenen (en vice versa) of van binair naar octaal om te rekenen (en vice versa).

<p>
De truc zit er hem in, dat een groep van 4 cijfers in het binaire stelsel, precies één cijfer in het hexadecimale stelsel heeft. Of dat een groep van 3 cijfers in het binaire stelsel, precies één cijfer in het octale stelsel heeft Zolang je onderstaande tabel in gedachten houdt, kun je elke kant op omrekenen.

<p>
    bin  hex      bin  oct   
   0000    0      000    0
   0001    1      001    1
   0010    2      010    2
   0011    3      011    3
   0100    4      100    4
   0101    5      101    5
   0110    6      110    6
   0111    7      111    7
   1000    8
   1001    9
   1010    A
   1011    B
   1100    C
   1101    D
   1110    E
   1111    F

<p>
==== Hexadecimaal <-> binair ====
<p>
Wil je weten wat 30F2<sub>(16)</sub> is in binair? Neem elk getal apart en schrijf deze op:

<p>
 hex     3     0    F    2
 bin  0011  0000 1111 0010

<p>
'''Conclusie''': 30F2<sub>(16)</sub> = 0011 0000 1111 0010<sub>(2)</sub>.

<p>
De andere kant op werkt net zo gemakkelijk. Wil je weten wat 11000011110010<sub>(2)</sub> is in hexadecimaal?

<p>
Groepeer eerst het binaire getal per 4 cijfers, '''beginnend aan de rechterkant'''. 
<p>
 bin 11 0000 1111 0010
<p>
Is er op het eind geen groep van 4, dan kun je hier nullen aan toevoegen.
<p>
 bin 0011 0000 1111 0010
<p>
Nu kun je per groep kijken welke cijfer er bij hoort
<p>
 bin 0011 0000 1111 0010
 hex    3    0    F    2

<p>
'''Conclusie''': 11000011110010<sub>(2)</sub> = 30F2<sub>(16)</sub>.

<p>
==== Octaal <-> binair ====
<p>
De omzetting octaal naar binair (en omgekeerd) is net zo gemakkelijk. Binnen deze cursus gaan we daar niet verder op in.

<p>
==== Decimaal <-> binair ====
<p>
De "shortcut" omzetting van decimaal naar binair lukt niet! Dit omdat het grondtal 10 geen macht is van twee. Om één decimaal cijfer voor te stellen zijn 3 bits namelijk te weinig (daar kan je maximaal 7 en niet 9 mee voorstellen) en zijn 4 bits te veel (daar kan je maximaal niet 9 mee voorstellen, maar 15).

<p>
Als je het toch probeert, krijg je fouten. Zo zou 74<sub>(10)</sub> met een shortcutomzetting waar vier bits worden gebruikt 0111 0100<sub>(2)</sub> = 01110100<sub>(2)</sub> worden, maar dat binaire getal is 116<sub>(10)</sub> (te bepalen via de somregel). Het juiste antwoord is 74<sub>(10)</sub>=1001010<sub>(2)</sub> (te bepalen via de Euclidische deling)!

<p>
'''Conclusie''': de omzetting decimaal <-> binair mag NIET via een shortcut!

<p>
=== Samenvatting ===
<p>
Voor het omrekenen tussen talstelsels zijn de volgende methoden gezien:

<p>
* (...)<sub>?</sub> -> (...)<sub>10</sub>: de somregel
<p>
* (...)<sub>10</sub> -> (...)<sub>?</sub>: de Euclidische deling
<p>
* (...)<sub>16</sub> <-> (...)<sub>2</sub>: shortcut
<p>
* (...)<sub>8</sub> <-> (...)<sub>2</sub>: shortcut

<p>
=== Rekenmachines ===
<p>
Bovenstaande manieren zijn handig om het principe van talstelsels te begrijpen, maar als je in de praktijk een omrekening te doen is het handiger om gebruik te maken van de mogelijkheden van je besturingssysteem. Zo bieden de rekenmachines van Windows of Gnome standaard de mogelijkheid om tussen talstelsels om te rekenen. Vaak moet je wel de modus van het rekentoestel veranderen.
<p>
[[Afbeelding:Gcalctool-scientific.png|thumb|Een rekentoestel onder Gnome, merk Bin Oct Dec en Hex op.]]

<p>
=== Oefeningen ===
<p>
Als je het omrekenen van het ene naar het andere talstelsels wil inoefenen, dan kan je de volgende oefeningen uitproberen. Als controle kan je het rekentoestel gebruiken.

<p>
# 101011<sub>(2)</sub> = ?<sub>(10)</sub>
<p>
# 78A<sub>(16)</sub> = ?<sub>(10)</sub>
<p>
# 11000011110010<sub>(2)</sub> = ?<sub>(16)</sub> 
<p>
# DEAD<sub>(16)</sub> = ?<sub>(2)</sub>
<p>
# 123<sub>(16)</sub> = ?<sub>(10)</sub>
<p>
# 123<sub>(10)</sub> = ?<sub>(2)</sub>
<p>
# 49233<sub>(10)</sub> = ?<sub>(16)</sub>
<p>
# 10101<sub>(10)</sub> = ?<sub>(16)</sub>
<p>
# 1110101<sub>(2)</sub> = ?<sub>(10)</sub>


</section>
</article>


</body>
</html>
